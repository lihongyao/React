# 概述

@See https://zh-hans.react.dev/learn/escape-hatches

在某些情况下，组件需要与 React 之外的系统进行交互和同步。例如，你可能需要：

1. 使用 **浏览器 API** 来手动聚焦输入框
2. 在 **没有 React** 的环境下管理视频播放器
3. 连接 **远程服务器** 并监听实时消息

本章将介绍几种 **脱围机制**，让你能够在必要时 **跳出 React 的范畴**，与外部系统进行连接和交互。不过，**大多数应用逻辑和数据流不应依赖这些功能**，而应尽量保持在 React 体系内。

# 使用 ref 引用值

@See https://zh-hans.react.dev/learn/referencing-values-with-refs

在 React 组件中，如果你需要 **记住某些信息**，但 **不希望这些信息触发组件的重新渲染**，可以使用 ref：

```tsx
const ref = useRef(0);
```

与 state 类似，ref 在组件的重新渲染之间会被 React **保留**。但与 state 不同的是，**更改 ref 不会触发组件重新渲染**，你可以通过 ref.current 访问 ref 的当前值。

## 如何使用 ref

```tsx
import { useRef } from "react";

export default function App() {
  const count = useRef(0);

  const handleClick = () => {
    count.current += 1;
    console.log(count.current); // 仅在控制台输出，不会导致 UI 变化
  };

  return <button onClick={handleClick}>点击</button>;
}
```

在这个示例中，每次点击按钮，count.current 的值都会增加，但 **组件不会重新渲染**。如果你希望 UI 更新，则应该使用 state 而不是 ref。

## ref 和 state 的区别

| 特性               | `ref`                                                | `state`                                                  |
| ------------------ | ---------------------------------------------------- | -------------------------------------------------------- |
| **定义方式**       | useRef                                               | useState                                                 |
| **值的更新方式**   | 直接修改 ref.current                                 | 通过 setState 更新                                       |
| **是否触发重渲染** | ❌ 不会触发组件重新渲染                               | ✅ 会触发组件重新渲染                                     |
| **数据存储位置**   | ref.current 属性                                     | React 的内部状态管理                                     |
| **常见用途**       | 访问 DOM、存储组件生命周期外的值                     | 管理组件内部动态更新的 UI 数据                           |
| **生命周期**       | 组件整个生命周期保持不变                             | 重新渲染时可能会被重新初始化                             |
| **性能影响**       | ✅ 适合存储不影响 UI 的数据                           | ⚠️ 更新状态可能会触发额外的渲染操作                       |
| **适用场景**       | - 引用 DOM 元素- 记录定时器 ID<br />- 维护非 UI 数据 | - UI 变化- 响应式数据流<br />- 依赖 React 渲染逻辑的数据 |

## 何时使用 Refs？

虽然 ref 是 React 提供的一个强大工具，但并不是所有情况都应该使用 ref。你通常会在 **需要“跳出”React 体系，与外部 API 交互** 时才会用到它，例如：

✅ **推荐使用 ref 的场景**：

- **存储 setTimeout 或 setInterval ID**，用于清除定时器
- **引用 DOM 元素**，如聚焦输入框、测量元素大小等
- **存储不会影响 JSX 计算的值**，如视频播放器的当前时间、WebSocket 连接实例等

❌ **不推荐使用 ref 代替 state**：

- 不要用 ref 存储 **影响 UI 的状态**，因为 ref 变化不会触发重新渲染
- 不要在 **渲染过程中** 修改 ref.current，否则可能导致组件行为难以预测

## ref 与 DOM 交互

在 React 中，ref 最常见的用法之一是 **访问 DOM 元素**。如果你希望以编程方式操作某个 DOM 元素，例如让输入框自动聚焦，你可以这样做：

```react
import { useRef, useEffect } from "react";

export default function App() {
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    inputRef.current?.focus(); // 组件挂载时自动聚焦
  }, []);

  return <input ref={inputRef} type="text" placeholder="自动聚焦输入框" />;
}
```

在这里：

1. useRef 创建了 inputRef，并绑定到 \<input> 元素的 ref 属性
2. useEffect 在组件挂载时 **自动聚焦输入框**
3. inputRef.current 直接引用了 DOM 元素

> **⚠️ 注意**：当元素从 DOM 中移除时，React 会将 ref.current 置为 null，避免访问不存在的元素。

## 总结

- ref 是 **React 的脱围机制**，用于存储不会触发渲染的值
- ref 是一个普通的对象，包含 current 属性，可以在组件生命周期内 **持久存储数据**
- useRef 适用于 **存储 DOM 引用、定时器 ID、外部 API 句柄等**
- **不要在渲染过程中** 修改 ref.current，否则会导致组件行为难以预测
- **如果数据影响 UI 需要更新**，请使用 state 而不是 ref

正确使用 ref，可以让你的 React 代码更加高效、可维护！

# 使用 ref 操作 DOM

@See https://zh-hans.react.dev/learn/manipulating-the-dom-with-refs

在 React 中，React 本身会处理 DOM 更新，你通常不需要手动操作 DOM。然而，在某些情况下，你可能需要访问由 React 管理的 DOM 元素，例如：

- 让输入框自动聚焦
- 滚动到某个元素
- 读取 DOM 元素的尺寸和位置

在 React 中，没有内置的方法来执行这些操作，你需要使用 ref 来访问 DOM 节点。

## 访问 DOM 元素

你可以使用 useRef 创建一个 ref，并将其赋值给 JSX 元素的 ref 属性。当该元素被挂载到 DOM 后，React 会将其 DOM 节点存储在 ref.current 中。

> 📖 **示例：自动聚焦输入框**

```tsx
import { useRef, useEffect } from "react";

export default function App() {
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    inputRef.current?.focus();
  }, []);

  return <input ref={inputRef} placeholder="请输入..." />;
}
```

> 📖 **示例：滚动到某个元素**

```tsx
import { useRef } from "react";

export default function App() {
  const divRef = useRef<HTMLDivElement>(null);

  const handleScrollToTop = () => {
    divRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  return (
    <div>
      <button onClick={handleScrollToTop}>返回顶部</button>
      <div className="h-screen bg-gray-200" ref={divRef}>
        滚动到此处
      </div>
    </div>
  );
}
```

> 📖 **ref 不能用于函数组件**

在 React 中，ref **不能** 直接用于函数组件，因为函数组件没有实例。以下代码会导致错误：

```tsx
import { useRef } from "react";

function MyComponent() {
  return <div>我是一个组件</div>;
}

export default function App() {
  const myComponentRef = useRef(null);
  return <MyComponent ref={myComponentRef} />; // ❌ 无效
}
```

如果想让 ref 作用于自定义组件，你需要使用 forwardRef。

## 在子组件中使用 ref

你可以将 ref 作为属性传递给子组件并操作子组件中的DOM元素，如下所示：

```tsx
import { useRef } from "react";

function Child({ ref }: { ref: React.RefObject<HTMLInputElement | null> }) {
  return <input ref={ref} placeholder="请输入..." />;
}
export default function App() {
  const ref = useRef<HTMLInputElement>(null);
  const handleClick = () => {
    ref.current?.focus();
  };
  return (
    <div>
      <Child ref={ref} />
      <button onClick={handleClick}>获取焦点</button>
    </div>
  );
}
```

## 通过 ref 暴露子组件方法

有时，你希望子组件暴露某些方法或数据供父组件调用。可以使用 useImperativeHandle 进行封装。

```tsx
import { useImperativeHandle, useRef } from "react";

interface ChildRefs {
  version: string;
  focus: () => void;
  getValue: () => string | undefined;
}
interface ChildProps {
  message: string;
  ref: React.RefObject<ChildRefs | null>;
}

function Child({ ref, ...props }: ChildProps) {
  const internalRef = useRef<HTMLInputElement>(null);
  // -- 使用 useImperativeHandle 定义暴露给父组件的属性和方法
  useImperativeHandle(ref, () => ({
    version: "1.0.0",
    focus: () => internalRef.current?.focus(),
    getValue: () => internalRef.current?.value,
  }));
  return (
    <div>
      <p>{props.message}</p>
      <input ref={internalRef} placeholder="请输入" />
    </div>
  );
}

export default function App() {
  const childRef = useRef<ChildRefs>(null);
  return (
    <div>
      <Child ref={childRef} message="Hello, React.js" />
      <button onClick={() => childRef.current?.focus()}>获取焦点</button>
      <button onClick={() => console.log(childRef.current?.getValue())}>读取数据</button>
    </div>
  );
}
```

## 何时使用 ref？

在 React 中，每次更新都分为 **渲染** 和 **提交** 两个阶段：

- **渲染阶段**：React 调用组件，计算新的 UI。
- **提交阶段**：React 将变更应用到 DOM。

**避免在渲染阶段访问 ref.current**，因为此时 DOM 可能还未创建或更新。通常，你应该在 **事件处理函数** 或 **useEffect** 中访问 ref.current。

**正确的示例（在 useEffect 中访问 ref）：**

```tsx
import { useEffect, useRef } from "react";

export default function App() {
  const divRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    console.log(divRef.current?.getBoundingClientRect());
  }, []);

  return <div ref={divRef}>获取尺寸信息</div>;
}
```

## ref 最佳实践

✅ **使用 ref 进行非 UI 影响的 DOM 操作**（如聚焦、滚动、测量）。

✅ **在 useEffect 或事件处理器中访问 ref**，避免在渲染阶段读取 ref.current。

✅ **用 useImperativeHandle 限制 ref 公开的方法**，避免子组件暴露过多实现细节。



🚫 **不要使用 ref 作为组件的主要数据存储**，通常 state 更合适。

🚫 **不要在渲染阶段访问 ref.current**，DOM 可能尚未更新。

🚫 **不要过度使用 ref 来操纵 DOM**，React 已经帮你管理大部分 DOM 变更。

## 摘要

- ref 主要用于操作 DOM，避免直接修改 React 管理的 UI 状态。
- 通过传递 `<div ref={myRef}>` 指示 React 将 DOM 节点放入 `myRef.current`。
- 通常，你会将 refs 用于非破坏性操作，例如聚焦、滚动或测量 DOM 元素。
- 默认情况下，组件不暴露其 DOM 节点。 你可以通过使用 `forwardRef` 并将第二个 `ref` 参数传递给特定节点来暴露 DOM 节点。
- 避免更改由 React 管理的 DOM 节点。
- 如果你确实修改了 React 管理的 DOM 节点，请修改 React 没有理由更新的部分。

ref 是 React 中的一个强大工具，但它应该是你的 **“备选方案”**，而不是 **“默认方案”**。在大多数情况下，React 的 **声明式渲染** 已经能满足需求，避免不必要的 DOM 操作可以让代码更易维护。

# 使用 Effect 进行同步

@See https://zh-hans.react.dev/learn/synchronizing-with-effects

在 React 开发中，我们经常会遇到一些需要与外部系统同步的场景。比如，你可能需要根据 React 的状态来控制一个非 React 的组件，或者当组件出现在屏幕上时发送一些分析日志。这时，React 的 `useEffect` 钩子就派上了用场。今天，我们就来聊聊 `useEffect` 是什么，它和事件（event）有什么区别，以及如何正确地使用它。

## 什么是 Effect？

在 React 中，组件的逻辑主要分为两种：**渲染逻辑**和**事件处理逻辑**。

- **渲染逻辑**：这是组件的核心逻辑，负责根据 `props` 和 `state` 来生成 UI。它必须是“**纯净**”的，就像数学公式一样，只负责计算结果，不应该有任何副作用。
- **事件处理逻辑**：这是由用户操作（比如点击按钮或输入文本）触发的逻辑。它通常包含一些副作用，比如更新输入字段、发送网络请求等。

然而，有些副作用并不是由用户操作直接触发的。比如，一个 `ChatRoom` 组件在屏幕上显示时需要连接到聊天服务器。这个连接操作并不是由某个特定的事件（如点击按钮）触发的，而是由组件的渲染本身引起的。这时，我们就需要使用 `useEffect` 来处理这种由渲染引起的副作用。

> 📒 **注意**
>
> 在本文此处和后续文本中，大写的 `Effect` 是 React 中的专有定义——由渲染引起的副作用。至于更广泛的编程概念(任何改变程序状态或外部系统的行为)，我们则使用“副作用（side effect）” 来指代。

## Effect 与事件的区别

简单来说，**事件是由用户操作触发的**，而 **Effect 是由渲染本身触发的**。比如，发送聊天消息是一个事件，因为它是由用户点击“发送”按钮触发的；而建立服务器连接是一个 Effect，因为它应该在组件显示时自动发生，无论用户进行了什么操作。

## 如何编写 Effect？

编写 Effect 需要遵循以下三个步骤：

1. **声明 Effect**：使用 `useEffect` 钩子来声明 Effect。默认情况下，Effect 会在每次渲染后执行。

   ```js
   useEffect(() => {
     // 每次渲染后都会执行这里的代码
   });
   ```

2. **指定依赖**：大多数 Effect 不需要在每次渲染后都执行。你可以通过指定依赖数组来控制 Effect 的执行时机。比如，一个淡入动画只需要在组件首次出现时触发。

   ```js
   useEffect(() => {
     // 只在 isPlaying 变化时执行
   }, [isPlaying]);
   ```

3. **添加清理函数**：有些 Effect 需要清理，比如断开服务器连接、取消订阅等。你可以在 Effect 中返回一个清理函数。

   ```js
   useEffect(() => {
     const connection = createConnection();
     connection.connect();
     return () => {
       connection.disconnect();
     };
   }, []);
   ```

## 如何处理在开发环境下 Effect 运行了两次？ 

在开发环境中，React 会故意重复挂载组件，以帮助你发现一些潜在的问题。比如，如果你忘记在 Effect 中添加清理函数，可能会导致内存泄漏或重复连接。React 通过重复挂载组件来确保你的 Effect 能够正确处理这些情况。

### 管理非 React 小部件 

在某些情况下，你可能需要在 React 组件中集成 **非 React 实现的 UI 组件**，例如地图、模态框等。这时，可以使用 useEffect 让它们与 React 状态保持同步。

#### **示例：同步地图缩放级别**

假设你有一个地图组件，并希望它的缩放级别 (zoomLevel) 与 React 组件中的状态同步，你可以这样使用 useEffect：

```tsx
useEffect(() => {
  const map = mapRef.current;
  map.setZoomLevel(zoomLevel);
}, [zoomLevel]);
```

在这个例子中，每当 zoomLevel 变化时，Effect 就会更新地图的缩放级别。

✅ **无需清理函数**：

- setZoomLevel 是一个幂等操作（即多次执行不会造成额外影响）。
- 在严格模式下，开发环境可能会触发 Effect 两次，但这不会影响生产环境的行为。

#### **示例：管理对话框（\<dialog>）的生命周期**

某些 API 不允许**连续调用相同的方法**，否则会抛出异常。例如，\<dialog> 元素的 `showModal()` 方法在被多次调用时会报错。因此，我们需要在 Effect 中**实现清理函数**，保证 Effect 重新运行时能够正确关闭对话框：

```tsx
useEffect(() => {
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close(); // 组件卸载或 Effect 重新运行时关闭对话框
}, []);
```

✅ **为什么需要清理函数？**

- 在**开发模式**下，React **会先调用 showModal()，然后立即调用 close()，再重新调用 showModal()**，以检测潜在的副作用问题。
- **在生产环境中，Effect 只会运行一次**，因此用户体验不会受到影响。

> 📖 **总结**

- **当非 React 组件的 API 允许重复调用时**（如 setZoomLevel），可以省略清理函数。

- **当 API 不允许重复调用时**（如 showModal），需要在 Effect 中提供清理函数，以确保行为正确。
- React **严格模式**下的二次挂载仅在开发环境中生效，不会影响生产环境的实际用户体验。

### 订阅事件

在 useEffect 中订阅事件时，**必须** 在清理函数中**取消订阅**，以防止**内存泄漏**或**重复绑定**事件监听器。

#### **示例：监听滚动事件**

以下 Effect 监听 window 的 scroll 事件，并在用户滚动页面时输出当前的 scrollX 和 scrollY 坐标：

```tsx
useEffect(() => {
  const handleScroll = () => console.log(window.scrollX, window.scrollY);
  window.addEventListener("scroll", handleScroll);
  return () => window.removeEventListener("scroll", handleScroll);
}, []);

```

✅ **为什么需要清理函数？**

- **防止内存泄漏**：如果 Effect 运行多次（如 zoomLevel 变化时），没有清理的话会导致**重复订阅**，从而创建多个无效的 handleScroll 监听器。
- **确保开发模式行为正确**：在**严格模式**下，React **会先添加监听器，再立即移除它，然后再重新添加**，最终只会保留一个有效的 handleScroll 订阅，确保行为与生产环境一致。

> 📖 **总结**

- **使用 useEffect 订阅事件时，一定要在清理函数中取消订阅**，以防止**重复绑定**和**内存泄漏**。
- **在开发环境（严格模式）下，React 会模拟卸载和重新挂载**，但不会影响生产环境的最终效果。
- **React 只会在依赖变化时重新运行 Effect**，因此绑定事件的 Effect 依赖数组通常是 []（即只在组件挂载和卸载时执行）。

### 触发动画

在 useEffect 中触发动画时，应**在清理函数中重置动画状态**，以确保组件卸载或重新渲染时不会产生意外视觉效果。

#### 示例：简单的透明度动画

以下 Effect 在组件挂载时触发**渐显动画**，并在组件卸载时重置透明度：

```tsx
useEffect(() => {
  const node = ref.current;
  if (!node) return;

  node.style.transition = "opacity 0.5s";
  node.style.opacity = "1"; // 触发动画

  return () => {
    node.style.opacity = "0"; // 重置为初始值
  };
}, []);
```

✅ **为什么需要清理函数？**

- **防止视觉闪烁**：如果组件被重新挂载，动画应从初始状态（opacity: 0）重新开始，而不是直接跳到最终状态。
- **确保开发模式行为一致**：在**严格模式**下，React **会先将 opacity 设为 1，再立即重置为 0，然后重新设为 1**，但最终可见效果与生产环境相同。

#### 使用第三方动画库

如果你使用 **GSAP**、**Framer Motion** 等动画库，清理函数应**重置时间轴**，确保动画不会在组件卸载后继续执行：

```tsx
useEffect(() => {
  const animation = gsap.to(ref.current, { opacity: 1, duration: 0.5 });

  return () => {
    animation.kill(); // 立即停止动画
  };
}, []);
```

✅ **适用于：**

- **CSS 过渡动画**（transition）
- **JS 动画库**（如 GSAP、anime.js）
- **Canvas/WebGL 动画**（如 Three.js）

> 📖 **总结**

- **在 useEffect 中触发动画时，应在清理函数中重置动画状态**，以避免组件卸载后产生**视觉残留**或**动画冲突**。
- **严格模式下 React 可能会额外执行一次清理，确保最终效果一致**。
- **如果使用动画库，应在清理函数中** **取消动画或重置时间轴**，防止组件卸载后仍在运行。

### 获取数据

在 useEffect 中获取数据时，React **不会自动取消已发出的网络请求**，因此需要手动处理，以防止数据竞争或错误更新 state。

#### 方法 1：忽略不相关的请求

当 userId 变化时，可能会有旧的请求比新的请求更晚返回，这会导致**过时的数据覆盖最新数据**。为了避免这种情况，可以引入**标志变量 ignore**，忽略不相关的响应：

```tsx
useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json); // 仅更新当前请求的数据
    }
  }

  startFetching();

  return () => {
    ignore = true; // 清理时忽略旧请求的结果
  };
}, [userId]);
```

✅ **为什么需要 ignore？**

- 如果 userId 从 **“Alice”** 变为 **“Bob”**，Alice 的请求可能**在 Bob 的请求之后返回**，导致 Bob 的数据被 Alice 的数据覆盖。
- 通过 if (!ignore) 确保 **只处理最新的请求**，即使旧请求返回得更慢，它的结果也不会影响 state。

🛠 **开发模式行为**

- 在 **严格模式** 下，React 会**发出两次相同的请求**，但第一次请求会立即被清理（ignore = true），不会影响 state。

- 在 **生产模式** 下，React 只会发出一次请求。

#### 方法 2：使用 AbortController 取消请求

相比于**仅忽略结果**，更好的方式是**直接取消过时的请求**，避免浪费网络资源：

```tsx
useEffect(() => {
  const controller = new AbortController();

  async function startFetching() {
    try {
      const response = await fetch(`/api/user/${userId}/todos`, {
        signal: controller.signal, // 绑定取消信号
      });
      const json = await response.json();
      setTodos(json);
    } catch (error) {
      if (error.name !== "AbortError") {
        console.error("请求失败:", error);
      }
    }
  }

  startFetching();

  return () => {
    controller.abort(); // 组件卸载或 userId 变化时取消请求
  };
}, [userId]);
```

✅ **为什么使用 AbortController？**

- 直接**取消请求**，而不是仅仅忽略结果，避免不必要的服务器负担。
- 处理网络错误，防止控制台出现**已取消请求的错误信息**。
- fetch 具备 signal 选项，可以安全地终止请求，而 axios 也有类似的 CancelToken 机制。

#### 方法 3：使用数据缓存库

如果你不想在 useEffect 里手动管理数据获取，可以使用 **React Query、SWR、Redux Toolkit Query** 等数据缓存库，它们可以**自动去重、缓存数据，并优化请求**。

```tsx
function TodoList() {
  const { data: todos } = useSWR(`/api/user/${userId}/todos`, fetchTodos);

  return (
    <ul>
      {todos?.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
```

✅ **优点**

- **自动缓存**：即使 userId 变化，React 仍然可以使用缓存数据，提高性能。
- **请求去重**：不会在短时间内发出多次相同请求，减少服务器压力。
- **错误处理内置**：无需在 useEffect 里手动 try-catch 处理异常。

> 📖 **总结**

| 方法                                | 适用场景                     | 优势                             |
| ----------------------------------- | ---------------------------- | -------------------------------- |
| **忽略旧请求** (`ignore` 标志)      | 轻量级数据请求，偶尔数据竞争 | 避免错误更新 `state`             |
| **使用 `AbortController` 取消请求** | 频繁更新数据，减少服务器负担 | 彻底取消不必要的请求             |
| **使用 SWR / React Query**          | 需要缓存 & 提升用户体验      | 自动管理请求，缓存数据，提高性能 |

对于**大部分应用**，使用 **SWR / React Query** 是最推荐的方案，可以**避免手动管理 useEffect，简化代码，提高性能**。

### 发送分析报告

在前端开发中，我们经常需要记录用户的访问行为，例如发送分析事件到服务器。一个常见的实现方式是使用 useEffect 在页面访问时触发 API 请求：

```tsx
import { useEffect } from 'react';

function PageTracker({ url }: { url: string }) {
  useEffect(() => {
    logVisit(url); // 发送分析请求
  }, [url]);

  return null;
}
```

这段代码在 url 变化时调用 logVisit(url)，记录访问情况。然而，在 **React 开发环境（严格模式）** 下，它会被 **调用两次**。那么，这是否需要修复呢？答案是 **不需要**。

### 什么时候不需要 Effect？

在 React 开发中，useEffect 主要用于处理副作用，例如数据获取、订阅事件或 DOM 操作。然而，并非所有逻辑都适合放入 Effect 中。如果误用 useEffect，可能会导致 **性能问题、数据重复请求、甚至引发严重的业务逻辑错误**。这里将介绍两种 **不适用于 Effect 的情况**，并提供更好的替代方案。

#### 不适用于 Effect：初始化应用

某些逻辑 **只需要在应用启动时运行一次**，比如：

- 检查用户认证状态
- 读取 localStorage 缓存
- 预加载一些全局数据

如果把这些逻辑放在 useEffect 里，可能会导致它们 **在组件重新挂载时重复执行**，甚至引发 **不必要的 API 请求**。最好的做法是 **直接在组件外部执行**，这样它们只会在应用启动时运行：

```tsx
if (typeof window !== 'undefined') { // 确保代码只在浏览器环境运行
  checkAuthToken(); // 检查用户登录状态
  loadDataFromLocalStorage(); // 读取本地缓存数据
}

function App() {
  return <MainComponent />;
}
```

**✅ 为什么这样做更好？**

1. **代码在应用启动时执行**，不会受组件的重新挂载影响。
2. **避免 useEffect 造成的额外副作用**，确保逻辑只执行一次。
3. **更符合直觉**，初始化操作和组件渲染解耦。

#### **不适用于 Effect：购买商品**

假设你正在开发一个电商应用，需要在用户进入 **订单支付页面** 时自动触发购买请求。如果你 **错误地** 把购买请求放在 useEffect 里，会导致 **开发环境下请求执行两次**，甚至可能在用户导航回页面时 **触发多次购买**：

```tsx
useEffect(() => {
  // ❌ 错误示例：这个请求可能会被执行多次
  fetch('/api/buy', { method: 'POST' });
}, []);
```

**⚠️ 为什么这样做是错误的？**

- 在 **开发环境** 下，React 严格模式会 **故意重新挂载组件**，导致 useEffect 运行两次，可能让用户 **购买两次相同的商品**。
- 在 **生产环境**，如果用户 **点击“返回”按钮重新进入购买页面**，Effect 也会重新运行，导致 **重复购买**。

**✅ 正确做法：将购买逻辑放入事件处理函数**

购买商品并不是 **渲染时触发的副作用**，而是 **用户点击购买按钮后触发的交互行为**，因此它应该放在 **事件处理函数** 中，而不是 useEffect 里：

```tsx
function handleClick() {
  // ✅ 只有用户点击时才执行购买操作
  fetch('/api/buy', { method: 'POST' });
}

return <button onClick={handleClick}>购买</button>;
```

**✅ 为什么这样更合理？**

- **只有用户点击按钮时才触发购买**，不会因组件重新挂载而重复执行。
- **符合直觉**，用户行为决定购买，而不是页面访问。
- **避免 API 重复请求**，防止误扣费等问题。

#### 总结

| ❌ 错误做法                    | ✅ 正确做法                         |
| ----------------------------- | ---------------------------------- |
| 在 useEffect 中执行初始化逻辑 | 在组件外部执行初始化操作           |
| 在 useEffect 里发送购买请求   | ****把购买逻辑放入按钮点击事件**** |

**🔹 何时使用 useEffect？**

- 处理 **副作用**（如订阅、数据获取、手动 DOM 操作）。
- 需要 **在组件生命周期中执行**，比如监听窗口大小变化。

**🔹 何时不使用 useEffect？**

- **应用初始化逻辑**（比如 localStorage、认证状态） → 应该放在组件外部。
- **用户交互触发的行为**（比如购买商品） → 应该放在事件处理函数中。

**🚀 结论**

React 严格模式的双调用 **暴露了错误的代码逻辑**，帮助我们构建更可靠的应用。**如果 useEffect 的重新执行破坏了应用逻辑，说明代码设计可能存在问题**。正确理解 Effect 的使用场景，才能写出 **高效、稳定** 的 React 代码！

# 你可能不需要 Effect

@See https://zh-hans.react.dev/learn/escape-hatches#you-might-not-need-an-effect

useEffect 是 React 的 **逃逸机制**，用于与 **外部系统**（如 API、DOM、订阅）同步。但如果你的逻辑 **只依赖于 React 自己的 state 和 props**，往往 **不需要 Effect**。移除不必要的 Effect 可以让代码更清晰、性能更好、bug 更少。

有两种常见的不必使用 Effect 的情况：

- **不必使用 Effect 来转换数据**

- **不必使用 Effect 来处理用户事件**

那如何移除不必要的 Effect 的呢？请往下看。

## 根据 props 或 state 更新 state？其实没必要！

你可能会想 **把计算值存入 state**，但这其实 **没必要**，还会 **增加复杂度**！

**❌ 错误示例：使用 Effect 计算 fullName**

```tsx
const [firstName, setFirstName] = useState('Taylor');
const [lastName, setLastName] = useState('Swift');
const [fullName, setFullName] = useState('');

useEffect(() => {
  setFullName(firstName + ' ' + lastName);
}, [firstName, lastName]);
```

**问题：**

- **多余的 state**：fullName 其实可以从 firstName 和 lastName 直接计算得出。
- **额外的渲染**：每次更新 firstName 或 lastName，都会先渲染一次，然后 useEffect 更新 fullName，再触发 **额外的渲染**。

**✅ 正确做法：直接计算！**

```tsx
const [firstName, setFirstName] = useState('Taylor');
const [lastName, setLastName] = useState('Swift');

const fullName = firstName + ' ' + lastName; // ✅ 直接计算
```

**为什么更好？**

✔ **避免额外的 state**，代码更简单

✔ **减少不必要的渲染**，性能更好

✔ **不会出现数据不同步问题**

> **记住：** 只要一个值能从 props 或 state 计算出来，就 **不应该存进 state**！

## **缓存昂贵的计算**

如果某个计算很耗时，或者每次渲染时都需要计算，而它并不是每次都变化，那你就可以 **缓存计算结果** 来提高性能。

**❌ 错误做法：不必要的 state 和 Effect**

```tsx
function TodoList({ todos, filter }) {
  const [visibleTodos, setVisibleTodos] = useState([]);
  
  useEffect(() => {
    setVisibleTodos(getFilteredTodos(todos, filter));
  }, [todos, filter]);
}
```

**问题：**

- 每次 todos 或 filter 变化时，都需要触发 useEffect 更新 visibleTodos。
- 不必要的 state 和 Effect 增加了复杂度，且每次渲染都会重新计算筛选。

**✅ 正确做法：直接计算**

```tsx
function TodoList({ todos, filter }) {
  const visibleTodos = getFilteredTodos(todos, filter);
}
```

**适用场景：**如果 getFilteredTodos() 是 **快速** 计算，直接计算就能解决问题。

**✅ 优化：使用 useMemo 缓存计算结果**

如果 getFilteredTodos() 计算很耗时，或者 todos 列表很大，你可以使用 useMemo 来缓存计算结果，避免每次渲染都重新计算。

```tsx
import { useMemo } from 'react';

function TodoList({ todos, filter }) {
  const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);
}
```

**为什么这样做：**

- **缓存计算结果**：当 todos 和 filter 没有变化时，useMemo 会直接返回上次计算的结果，避免不必要的计算。
- **提高性能**：尤其是在计算过程很复杂或者数据量大的时候，避免了重复计算。

> **注意**：useMemo 只适用于 **纯函数**（没有副作用的函数），并且它只会在依赖变化时重新计算。

## 当 props 变化时重置所有 state

有时候，当某个 prop 变化时，你需要重置组件中的 state，比如在用户切换个人资料时清空评论框。

**❌ 错误做法：使用 Effect 重置 state**

```tsx
export default function ProfilePage({ userId }) {
  const [comment, setComment] = useState('');

  // 🔴 避免：在 Effect 中重置 state
  useEffect(() => {
    setComment('');
  }, [userId]);

  // ...
}
```

**问题：**

- 这种做法会导致不必要的两次渲染：首先是用旧值渲染，然后再用新值重新渲染。
- 如果页面有多个嵌套组件，也需要在每个组件中添加相似的 Effect，增加了复杂度。

**✅ 正确做法：通过 key 重置组件状态**

```tsx
export default function ProfilePage({ userId }) {
  return (
    <Profile
      userId={userId}
      key={userId}  // 使用 userId 作为 key
    />
  );
}

function Profile({ userId }) {
  const [comment, setComment] = useState('');
  // ...
}
```

**为什么这样做：**

- React 会根据 key 判断组件是否需要重新创建。当 userId 变化时，Profile 组件和它的所有子组件都会被重新创建，state 会被重置。
- 通过这种方式，你不需要显式地清空 comment，React 会自动处理状态重置。

> 📖 **总结**

- 使用 key 重置组件状态比在 useEffect 中手动清除 state 更加高效、简洁。
- 只需要在外层组件传递 key，React 会自动在 key 变化时重置组件的 state。

## 当 prop 变化时调整部分 state

有时你希望根据 prop 的变化调整部分 state，而不是重置所有的 state。这种情况下，我们需要谨慎避免不必要的渲染。

**❌ 错误做法：使用 Effect 调整 state**

```tsx
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // 🔴 避免：在 Effect 中调整 state
  useEffect(() => {
    setSelection(null);
  }, [items]);
  // ...
}
```

**问题：**

- 每当 items 变化时，组件会先用旧的 selection 值渲染，接着 React 会更新 DOM，然后再执行 Effect，最后重置 selection。
- 这会导致不必要的两次渲染和复杂的状态更新流程。

**✅ 正确做法：在渲染期间调整 state**

```tsx
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // 好一些：在渲染期间调整 state
  const [prevItems, setPrevItems] = useState(items);
  if (items !== prevItems) {
    setPrevItems(items);
    setSelection(null);
  }
  // ...
}
```

**解释：**

- 在渲染期间直接调整 state，避免了不必要的副作用。
- 这样可以确保组件在每次渲染时及时更新 selection，并避免了多余的渲染。

**更好的做法：直接在渲染期间计算需要的内容**

```tsx
function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selectedId, setSelectedId] = useState(null);

  // ✅ 非常好：在渲染期间计算所需内容
  const selection = items.find(item => item.id === selectedId) ?? null;
  // ...
}
```

**为什么这样做：**

- 直接计算 selection，避免了修改 state 的复杂逻辑。
- 通过存储已选中的项 ID 而非整个选中项，可以在渲染时动态计算选中的项。
- 这种方法让 state 保持更简洁，并且对于 items 的变化，React 会直接计算最新的 selection，避免了不必要的 state 调整和重新渲染。

> 📖 **总结**

- 尽量避免在 Effect 中调整部分 state，这会引起不必要的渲染。
- 在渲染期间计算所需的内容是更高效的做法。
- 通过存储简单的值（如 selectedId），而不是整个 selection，可以避免复杂的状态管理。

## 在事件处理函数中共享逻辑

当多个事件处理函数需要执行相同的逻辑时，将共享逻辑提取到一个单独的函数中是个更好的选择，而不是在 useEffect 中处理。这有助于保持组件的清晰性，避免不必要的副作用，也能减少重复代码。

**❌ 错误做法：在 useEffect 中处理事件特定的逻辑**

```tsx
function ProductPage({ product, addToCart }) {
  // 🔴 避免：在 Effect 中处理属于事件特定的逻辑
  useEffect(() => {
    if (product.isInCart) {
      showNotification(`已添加 ${product.name} 进购物车！`);
    }
  }, [product]);

  function handleBuyClick() {
    addToCart(product);
  }

  function handleCheckoutClick() {
    addToCart(product);
    navigateTo('/checkout');
  }
  // ...
}
```

**问题：**

- useEffect 被用来处理按钮点击时需要执行的逻辑。
- product.isInCart 的变化导致了不必要的通知，即使页面刷新后，product.isInCart 可能依旧为 true，这会导致重复的通知显示。
- 在这种情况下，useEffect 并不适合处理这种事件特定的逻辑，它应该用于副作用代码，而不是事件处理的逻辑。

**✅ 正确做法：将共享逻辑放入事件处理函数中**

```tsx
function ProductPage({ product, addToCart }) {
  // ✅ 非常好：事件特定的逻辑在事件处理函数中处理
  function buyProduct() {
    addToCart(product);
    showNotification(`已添加 ${product.name} 进购物车！`);
  }

  function handleBuyClick() {
    buyProduct();
  }

  function handleCheckoutClick() {
    buyProduct();
    navigateTo('/checkout');
  }
  // ...
}
```

**优点：**

- 将 buyProduct 函数提取出来，使得两个事件处理函数共享相同的逻辑（添加到购物车并显示通知）。
- 这样，逻辑明确，易于管理，避免了不必要的副作用。
- 当按钮被点击时，只有在点击时才会触发通知，而不是因为页面渲染时的状态变化。

> 📖 **总结**

- 当某些逻辑是由事件触发的（比如按钮点击），应当把它放入事件处理函数中，而不是 useEffect。
- useEffect 主要用来处理副作用（如数据获取、订阅等），而不是处理用户交互事件。
- 提取共享逻辑到一个单独的函数中，可以减少重复代码，提高可读性。

## 发送 POST 请求

在 React 组件中发送 POST 请求时，需要明确区分 **页面加载时执行的请求** 和 **用户交互触发的请求**。

**❌ 错误做法：在 useEffect 中处理事件触发的请求**

```tsx
function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  // ✅ 这个逻辑应该在组件显示时执行
  useEffect(() => {
    post('/analytics/event', { eventName: 'visit_form' });
  }, []);

  // 🔴 避免：在 Effect 中处理属于事件特定的逻辑
  const [jsonToSubmit, setJsonToSubmit] = useState(null);
  useEffect(() => {
    if (jsonToSubmit !== null) {
      post('/api/register', jsonToSubmit);
    }
  }, [jsonToSubmit]);

  function handleSubmit(e) {
    e.preventDefault();
    setJsonToSubmit({ firstName, lastName });
  }
}
```

**问题**

- **useEffect 监听 jsonToSubmit 并触发 POST 请求**：
  - 这导致每次 jsonToSubmit 变化时，都会发送请求。
  - **请求的触发方式不直观**，会导致不必要的状态更新和潜在的重复请求问题。
- **发送请求的逻辑与用户交互逻辑分离**：
  - handleSubmit 只是更新 jsonToSubmit 状态，而不是直接发送请求。
  - 这样不利于代码的可读性和维护性。

**✅ 正确做法：在事件处理函数中发送请求**

```tsx
function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  // ✅ 这个逻辑应该在组件显示时执行
  useEffect(() => {
    post('/analytics/event', { eventName: 'visit_form' });
  }, []);

  function handleSubmit(e) {
    e.preventDefault();
    // ✅ 事件特定的逻辑应该在事件处理函数中执行
    post('/api/register', { firstName, lastName });
  }
}
```

**优点**

✅ **清晰的逻辑划分**：

- **分析请求 (/analytics/event) 属于副作用**，应该放在 useEffect 中，只执行一次。
- **表单提交 (/api/register) 由事件触发**，应该放在 handleSubmit 事件处理函数中。

✅ **避免了不必要的状态管理**

- 直接在 handleSubmit 里调用 post，不需要额外的 useState (jsonToSubmit) 来存储请求数据。

✅ **减少了不必要的渲染**

- 由于 useEffect 不再监听 jsonToSubmit，组件不会因为 setJsonToSubmit 触发的 state 变化而重新渲染。

> 📖 **总结**

📌 **判断逻辑应该放在哪里的关键**：

- **如果某个逻辑是由“组件渲染”触发的（例如分析请求）** ➝ **放在 useEffect 里**
- **如果某个逻辑是由“用户交互”触发的（例如表单提交）** ➝ **放在事件处理函数里**

📌 **最佳实践**：

1. **避免在 useEffect 里处理用户交互事件**
2. **尽量减少 useState，避免不必要的状态存储**
3. **事件处理函数应该直接执行需要的逻辑**，而不是更新 state 后由 useEffect 触发

## 链式计算

在 React 组件中，过多的 useEffect 可能会导致 **性能问题** 和 **状态管理复杂度增加**。尤其是 **链式 useEffect**，它会导致多个状态更新触发不必要的重新渲染。

**❌ 错误示例：链式 useEffect 触发多个状态更新**

```tsx
function Game() {
  const [card, setCard] = useState(null);
  const [goldCardCount, setGoldCardCount] = useState(0);
  const [round, setRound] = useState(1);
  const [isGameOver, setIsGameOver] = useState(false);

  // 🔴 触发 `setGoldCardCount`
  useEffect(() => {
    if (card !== null && card.gold) {
      setGoldCardCount(c => c + 1);
    }
  }, [card]);

  // 🔴 触发 `setRound`
  useEffect(() => {
    if (goldCardCount > 3) {
      setRound(r => r + 1);
      setGoldCardCount(0);
    }
  }, [goldCardCount]);

  // 🔴 触发 `setIsGameOver`
  useEffect(() => {
    if (round > 5) {
      setIsGameOver(true);
    }
  }, [round]);

  // 🔴 触发 `alert`
  useEffect(() => {
    alert('游戏结束！');
  }, [isGameOver]);

  function handlePlaceCard(nextCard) {
    if (isGameOver) {
      throw Error('游戏已经结束了。');
    } else {
      setCard(nextCard);
    }
  }
}
```

**问题**

- **额外的渲染次数**
  - setCard → 渲染 → setGoldCardCount → 渲染 → setRound → 渲染 → setIsGameOver → 渲染
  - **多次状态更新导致多次重新渲染**，性能开销大。
- **代码变得脆弱**
  - 如果需要修改状态更新逻辑（比如调整 goldCardCount 的计算方式），可能会破坏 useEffect 链。
  - **难以扩展**，尤其是当你需要回溯游戏历史时，设置 card 可能会重新触发 useEffect。

**✅ 最佳实践：在事件处理函数中一次性计算所有状态**

```tsx
function Game() {
  const [card, setCard] = useState(null);
  const [goldCardCount, setGoldCardCount] = useState(0);
  const [round, setRound] = useState(1);

  // ✅ 在渲染期间计算 `isGameOver`
  const isGameOver = round > 5;

  function handlePlaceCard(nextCard) {
    if (isGameOver) {
      throw Error('游戏已经结束了。');
    }

    // ✅ 在事件处理函数中计算所有状态，避免多次渲染
    setCard(nextCard);

    if (nextCard.gold) {
      if (goldCardCount < 3) {
        setGoldCardCount(goldCardCount + 1);
      } else {
        setGoldCardCount(0);
        setRound(round + 1);
        if (round === 5) {
          alert('游戏结束！');
        }
      }
    }
  }
}
```

优点

- **只渲染一次**
  - 事件处理函数内部执行 setCard、setGoldCardCount 和 setRound，但 **React 只会在事件结束后触发一次渲染**。
  - 避免 useEffect 导致的 **额外渲染**。
- **逻辑更清晰**
  - isGameOver 直接基于 round 计算，而不是等待 useEffect 触发状态更新。
  - handlePlaceCard 内部 **一次性更新所有状态**，逻辑集中、易于维护。
- **易于扩展**
  - 如果要 **回溯游戏历史**，直接更新 card、goldCardCount 和 round，不会触发 useEffect 重新执行导致状态混乱。

## 初始化应用

在 React 应用中，**某些逻辑只需要在应用加载时执行一次**，例如：

- **从 localStorage 读取数据**
- **检查身份验证 token**
- **设置全局配置**

但如果不小心，**useEffect 可能会执行两次**，尤其是在 **React 严格模式（Strict Mode）** 下。接下来我们将探讨如何正确初始化应用。

**❌ 常见错误：直接在 useEffect 里执行**

```tsx
function App() {
  useEffect(() => {
    loadDataFromLocalStorage();
    checkAuthToken();
  }, []);
}
```

**存在的问题**

1. **开发环境下执行两次**
   - 在 **React 严格模式** (StrictMode) 中，React **会在开发模式下调用 useEffect 两次**（仅限 React 18+）。
   - 可能导致 **身份验证 token 失效**、**数据被重复处理**。
2. **在组件重新挂载时可能意外触发**
   - useEffect(() => ..., []) 在 **组件挂载时执行**，但如果 App 组件因为某些原因被卸载再重新挂载，会导致 useEffect 再次执行。

**✅ 解决方案 1：使用顶层变量**

在模块作用域声明一个变量 **didInit**，确保逻辑 **仅执行一次**：

```tsx
let didInit = false;

function App() {
  useEffect(() => {
    if (!didInit) {
      didInit = true;
      loadDataFromLocalStorage();
      checkAuthToken();
    }
  }, []);
}
```

**为什么这样能解决问题？**

- **didInit 变量是全局的（模块作用域），不会因为组件重新渲染而重置**。
- **即使 App 组件被重新挂载，didInit 依然保持 true，避免重复执行**。

**✅ 解决方案 2：在模块初始化时执行**

在应用渲染 **之前** 执行初始化逻辑：

```tsx
if (typeof window !== 'undefined') { // 确保在浏览器环境执行
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // 组件渲染逻辑
}
```

**适用于哪些情况？**

- 适用于 **只需要在应用加载时执行一次的代码**（如 **身份验证检查**）。
- **不会因为组件重新挂载而重复执行**。

>  **注意**
>
> - **不要过度使用**，因为 **顶层代码会在组件被导入时执行，即使组件最终没有被渲染**。
> - **适合 App.js 这种应用入口组件**，不要在普通组件中使用。

**✅ 解决方案 3：使用 useRef 存储初始化状态**

```tsx
function App() {
  const didInit = useRef(false);

  useEffect(() => {
    if (!didInit.current) {
      didInit.current = true;
      loadDataFromLocalStorage();
      checkAuthToken();
    }
  }, []);
}
```

 **为什么 useRef 适合？**

- useRef **在组件的整个生命周期内保持不变**，不会因为 **重新渲染** 而重置。
- 但 **如果 App 组件被卸载再重新挂载，useRef 仍然会被重置**，这点不同于模块作用域的 didInit。

**什么时候仍然应该使用 useEffect？**

- 需要 **监听依赖项变化** 时，例如：

  ```tsx
  useEffect(() => {
    console.log(`当前用户 ID: ${userId}`);
  }, [userId]); // userId 变化时执行
  ```

- 需要在 **组件挂载和卸载时执行副作用**（如订阅 WebSocket）：

  ```tsx
  useEffect(() => {
    const socket = new WebSocket('wss://example.com');
    return () => socket.close(); // 组件卸载时清理
  }, []);
  ```

**最佳实践**

- **应用级别初始化** 👉 **模块作用域变量** 或 **顶层执行**
- **组件级别初始化** 👉 **useRef 记录状态**
- **监听状态变化或副作用** 👉 **useEffect**

## 通知父组件有关 state 变化的信息

在 React 组件设计中，**子组件的 state 变化需要通知父组件**，以便父组件可以做出相应的反应。例如，一个 Toggle 组件（开关按钮）可能需要通知父组件它是 **开** (true) 还是 **关** (false)。

**❌ 不理想的方式：使用 useEffect 触发 onChange**

```tsx
function Toggle({ onChange }) {
  const [isOn, setIsOn] = useState(false);

  useEffect(() => {
    onChange(isOn);
  }, [isOn, onChange]);

  function handleClick() {
    setIsOn(!isOn);
  }

  function handleDragEnd(e) {
    if (isCloserToRightEdge(e)) {
      setIsOn(true);
    } else {
      setIsOn(false);
    }
  }

  // ...
}
```

**存在的问题**

1. **onChange 触发的时间太晚**
   - setIsOn 先更新 isOn，React 触发重新渲染后才执行 useEffect 里的 onChange，**父组件收到状态变化时已经是下一次渲染**。
   - **可能导致额外的渲染，降低性能**。
2. **父组件 state 和子组件 state 不同步**
   - isOn 更新后，**子组件 UI 先更新，父组件可能会滞后**，导致状态不同步。

**✅ 更好的方式：在事件处理函数中同时更新子组件和父组件的 state**

```tsx
function Toggle({ onChange }) {
  const [isOn, setIsOn] = useState(false);

  function updateToggle(nextIsOn: boolean) {
    // ✅ 在同一事件处理流程中更新所有 state，保持同步
    setIsOn(nextIsOn);
    onChange(nextIsOn);
  }

  function handleClick() {
    updateToggle(!isOn);
  }

  function handleDragEnd(e: DragEvent) {
    if (isCloserToRightEdge(e)) {
      updateToggle(true);
    } else {
      updateToggle(false);
    }
  }

  return <button onClick={handleClick}>{isOn ? 'ON' : 'OFF'}</button>;
}
```

**为什么这样更好？**

- **避免 useEffect 造成的额外渲染**
- **保证 isOn 和 onChange 传递的值始终同步**
- **React 会批量更新 state，减少不必要的渲染**

**✅ 最优方案：提升 state（Controlled Component）**

如果 Toggle 组件的 state 只用于控制 UI，完全可以交给 **父组件管理**，让 Toggle 变成 **受控组件（Controlled Component）**。

```tsx
function Toggle({ isOn, onChange }) {
  function handleClick() {
    onChange(!isOn);
  }

  function handleDragEnd(e: DragEvent) {
    onChange(isCloserToRightEdge(e));
  }

  return <button onClick={handleClick}>{isOn ? 'ON' : 'OFF'}</button>;
}
```

**适用于哪些场景？**

1. Toggle **的 isOn 状态受控于父组件**，子组件只负责 **UI 交互**。
2. **父组件完全控制状态**，子组件变得更简单，避免了 **多个 state 需要同步** 的问题。

**🔥 状态提升 的应用示例**

**父组件**

```tsx
function Parent() {
  const [isOn, setIsOn] = useState(false);

  return (
    <div>
      <Toggle isOn={isOn} onChange={setIsOn} />
      <p>当前状态: {isOn ? '开' : '关'}</p>
    </div>
  );
}
```

**这样做的好处**

1. **Toggle 组件没有自己的 state，减少了状态管理的复杂性**。
2. **Parent 组件可以随时获取 isOn 的值，并决定如何处理**（比如存入 localStorage 或触发 API 调用）。
3. **Toggle 组件变得可复用**，它的行为完全由 props 控制，避免了组件内部 state 导致的难以调试的问题。

**最佳实践**

- **如果组件的 state 只影响自身 UI**，可以 **在 onChange 里同步更新**。
- **如果 state 需要在多个组件之间共享**，**考虑状态提升，让父组件控制 state**。
- **避免在 useEffect 里触发 onChange**，这样 state 变化会滞后，并导致额外渲染。

## 将数据传递给父组件

在 React 组件的 **数据流** 设计中，父组件通常向子组件传递 props，但有时子组件会获取数据，并需要传递给父组件处理。这里需要注意 **数据同步的问题**，避免不必要的渲染。

**❌ 反模式：在 useEffect 里传递数据**

```tsx
function Parent() {
  const [data, setData] = useState(null);
  return <Child onFetched={setData} />;
}

function Child({ onFetched }) {
  const data = useSomeAPI();

  // 🔴 避免：在 Effect 中传递数据给父组件
  useEffect(() => {
    if (data) {
      onFetched(data);
    }
  }, [onFetched, data]);

  return <div>子组件</div>;
}
```

**存在的问题**

1. **数据流变得不可预测**
   - data 是在子组件 useEffect 里 **异步更新** 的，导致 Parent **接收到数据的时间不确定**。
   - 这可能会触发 **额外的渲染**，甚至导致状态不一致。
2. **组件的渲染与数据获取解耦**
   - Parent 组件**并不知道何时数据会到达**，使得调试变得困难。

**✅ 最佳方案：在 Parent 里获取数据，并向 Child 传递**

```tsx
function Parent() {
  const data = useSomeAPI();

  // ✅ 父组件直接获取数据，并传递给子组件
  return <Child data={data} />;
}

function Child({ data }) {
  return <div>子组件数据：{data}</div>;
}
```

**为什么这样更好？**

- **数据流向更清晰**：数据 **只从父组件流向子组件**，而不会在 useEffect 里意外触发更新。
- **避免额外渲染**：减少 useEffect 依赖项的影响，避免 setData 触发 Parent 重新渲染。
- **父组件可控性更高**：Parent 可以决定如何处理数据，甚至可以缓存数据或提供 loading 状态。

**🔥 适用于多个组件的数据共享**

当 Child 组件 **只负责展示数据**，而多个组件都需要用到 data 时，让 Parent 处理数据更合理：

```tsx
function Parent() {
  const data = useSomeAPI();

  return (
    <div>
      <Child data={data} />
      <AnotherComponent data={data} />
    </div>
  );
}

function Child({ data }) {
  return <p>子组件：{data}</p>;
}

function AnotherComponent({ data }) {
  return <p>另一个组件：{data}</p>;
}
```

**这样做的好处**

- 让 Parent 统一管理 data，**减少不必要的 API 请求**。
- 让所有子组件 **同步获取相同的数据**，**不需要子组件单独管理状态**。
- **更容易维护**，如果 data 需要缓存或优化，Parent 只需要做一次优化。

**最佳实践**

- **让 Parent 负责获取数据，并把数据作为 props 传递给 Child**。
- **避免在 useEffect 里通知 Parent 更新 state**，这可能会导致状态不同步。
- **如果多个子组件都需要 data，父组件负责管理数据可以减少 API 请求**，提高性能。

## 订阅外部 store 

在某些情况下，React 组件需要订阅 **外部数据源**（如浏览器 API、第三方状态管理库等）。由于这些数据源是 **React 无法直接感知** 的，所以需要手动监听数据变化并更新组件状态。

**❌ 传统方式：在 useEffect 中订阅**

```tsx
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(true);

  useEffect(() => {
    function updateState() {
      setIsOnline(navigator.onLine);
    }

    updateState(); // 初始化 state

    window.addEventListener('online', updateState);
    window.addEventListener('offline', updateState);

    return () => {
      window.removeEventListener('online', updateState);
      window.removeEventListener('offline', updateState);
    };
  }, []);

  return isOnline;
}

function ChatIndicator() {
  const isOnline = useOnlineStatus();
  return <div>{isOnline ? "🟢 在线" : "🔴 离线"}</div>;
}
```

**存在的问题**

1. **手动管理订阅**
   - 需要在 useEffect 里手动 **监听和清除** 事件，容易遗漏或者写错。
2. **组件重新渲染时可能重复订阅**
   - 如果 useEffect 的依赖项变化不当，可能会导致 **多次订阅**，造成内存泄漏或性能问题。

**✅ 推荐方式：使用 useSyncExternalStore**

React 提供了 useSyncExternalStore 这个 Hook，专门用于 **订阅外部数据源**，它能保证数据流的一致性，并且优化了 **性能** 和 **渲染行为**。

```tsx
import { useSyncExternalStore } from "react";

function subscribe(callback: () => void) {
  window.addEventListener("online", callback);
  window.addEventListener("offline", callback);

  return () => {
    window.removeEventListener("online", callback);
    window.removeEventListener("offline", callback);
  };
}

function useOnlineStatus() {
  return useSyncExternalStore(
    subscribe, // 订阅函数
    () => navigator.onLine, // 客户端获取值的方法
    () => true // 服务器端获取值的方法（SSR）
  );
}

function ChatIndicator() {
  const isOnline = useOnlineStatus();
  return <div>{isOnline ? "🟢 在线" : "🔴 离线"}</div>;
}
```

**为什么 useSyncExternalStore 更好？**

| 方案                      | 适用场景                                               | 优势                                         |
| ------------------------- | ------------------------------------------------------ | -------------------------------------------- |
| 手动 useEffect 订阅       | 适用于简单订阅                                         | ❌ 需要手动管理，可能导致重复订阅、内存泄漏   |
| useSyncExternalStore 订阅 | 适用于监听外部 Store（如浏览器 API、全局状态管理库等） | ✅ React 内置优化，自动处理订阅，防止重复渲染 |

 **useSyncExternalStore 的优势**

1. **自动管理订阅**：避免 useEffect 需要手动 addEventListener / removeEventListener。
2. **防止不必要的渲染**：useSyncExternalStore 只有在外部数据发生变化时才触发更新，而不会因为组件重新渲染而重复订阅。
3. **支持服务器端渲染（SSR）**：可以在 getServerSnapshot 提供默认值，防止 navigator.onLine 在 SSR 时报错。

> 📖 **总结**

- useSyncExternalStore 是 **订阅外部数据源的最佳选择**，避免了 useEffect 可能带来的 **性能问题** 和 **状态不一致** 的情况。
- useSyncExternalStore 适用于：
  - 监听 **浏览器 API**（如 navigator.onLine）。
  - 订阅 **外部状态管理库**（如 Redux、MobX）。
  - 其他 **React 之外的数据源**。

## 获取数据

在 React 应用中，**数据获取** 是一个常见需求。通常，我们会在 useEffect 中发起网络请求，但如果处理不当，可能会导致 **竞态条件**、**不必要的请求**、**重复渲染** 等问题。

**❌ 传统方式：直接在 useEffect 里发请求**

```tsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  const [page, setPage] = useState(1);

  useEffect(() => {
    fetchResults(query, page).then(json => {
      setResults(json);
    });
  }, [query, page]);

  function handleNextPageClick() {
    setPage(page + 1);
  }
  // ...
}
```

**存在的问题**

1. **竞态条件（Race Condition）**
   - 用户快速输入 hello，每个字母变化都会触发新的请求，但返回顺序可能不一致，导致**旧请求覆盖新请求**的数据。
2. **无法取消已发出的请求**
   - React 不会自动取消 fetchResults()，如果前一个请求的响应比后一个请求慢，就可能出现**错误的数据**。

**✅ 解决方案：在 useEffect 里清除旧请求**

在 useEffect 里，我们可以使用一个 **标记变量 ignore** 来忽略过期的请求：

```tsx
function SearchResults({ query }) {
  const [results, setResults] = useState([]);
  const [page, setPage] = useState(1);

  useEffect(() => {
    let ignore = false;
    fetchResults(query, page).then(json => {
      if (!ignore) {
        setResults(json);
      }
    });

    return () => {
      ignore = true;
    };
  }, [query, page]);

  function handleNextPageClick() {
    setPage(page + 1);
  }
  // ...
}
```

**这样做的好处**

- **防止旧数据覆盖新数据**
- **保证 setResults 只更新最后一次请求的数据**

**🚀 进一步优化：提取到自定义 Hook**

```tsx
function useData(url) {
  const [data, setData] = useState(null);

  useEffect(() => {
    let ignore = false;
    
    fetch(url)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setData(json);
        }
      });

    return () => {
      ignore = true;
    };
  }, [url]);

  return data;
}

function SearchResults({ query }) {
  const [page, setPage] = useState(1);
  const params = new URLSearchParams({ query, page });
  const results = useData(`/api/search?${params}`);

  function handleNextPageClick() {
    setPage(page + 1);
  }
  // ...
}
```

**为什么要封装成 useData？**

1. **代码更清晰，职责单一**（SearchResults 组件专注于 UI，useData 负责数据获取）
2. **方便复用**（不同组件都能用 useData 获取数据）
3. **更容易扩展**（可以在 useData 里加入**错误处理**、**缓存**、**loading 状态**等）

**🔥 进一步优化：支持 abortController**

使用 AbortController 可以 **真正取消请求**，而不仅仅是忽略过期的请求：

```tsx
function useData(url) {
  const [data, setData] = useState(null);

  useEffect(() => {
    const controller = new AbortController();
    const signal = controller.signal;

    fetch(url, { signal })
      .then(response => response.json())
      .then(json => setData(json))
      .catch(err => {
        if (err.name !== "AbortError") {
          console.error("数据获取失败", err);
        }
      });

    return () => {
      controller.abort(); // 组件卸载时取消请求
    };
  }, [url]);

  return data;
}
```

**这样做的好处**

- **取消不必要的请求**（不只是忽略，而是直接终止）
- **防止内存泄漏**（React 组件卸载时，abort 会终止正在进行的请求）

**什么时候该用 useEffect 进行数据获取？**

**✅ 适合 useEffect 进行数据获取的情况**

- **数据依赖于组件状态**（如 query、page 变化时重新请求）
- **组件挂载时需要请求数据**
- **手动管理数据请求**

**🚀 更推荐的方式**

对于 **复杂的数据获取**，如：

- **缓存**（避免重复请求相同数据）
- **错误处理**
- **全局数据管理**
- **避免瀑布式请求**

可以使用 **更高级的方案**：

1. **React Query (@tanstack/react-query)** - 处理缓存、状态管理、错误处理、自动请求重试等
2. **SWR (swr 库)** - 类似 React Query，支持自动数据重新验证

例如，使用 React Query：

```tsx
import { useQuery } from '@tanstack/react-query';

function useData(url) {
  return useQuery(['data', url], () =>
    fetch(url).then(res => res.json())
  );
}
```

**这样做的优势**

- **自动缓存**（避免重复请求相同数据）
- **支持错误处理、重试、后台数据刷新**
- **优化 loading 体验**

**最佳实践**

1. **简单数据请求** ➝ useEffect + ignore
2. **可复用的数据获取** ➝ useData 自定义 Hook
3. **复杂数据管理（缓存、自动重试）** ➝ React Query 或 SWR

# 响应式 Effect 的生命周期

@See https://zh-hans.react.dev/learn/lifecycle-of-reactive-effects

# 将事件从 Effect 中分开

@See https://zh-hans.react.dev/learn/separating-events-from-effects

# 移除 Effect 依赖

@See https://zh-hans.react.dev/learn/removing-effect-dependencies

# 使用自定义 Hook 复用逻辑

@See https://zh-hans.react.dev/learn/reusing-logic-with-custom-hooks

React 提供了一些内置 Hook，如 useState、useContext 和 useEffect，但在某些情况下，你可能需要更具体的功能，比如获取数据、检测用户是否在线或管理聊天室连接。虽然 React 本身没有这些 Hook，但你可以根据需求封装自己的自定义 Hook，方便复用和管理逻辑。

## 自定义 Hook：组件间共享逻辑

为了避免在多个组件中重复监听网络状态的逻辑，可以将其封装成一个自定义 Hook：

```tsx
function useOnlineStatus() {
  const [isOnline, setIsOnline] = useState(navigator.onLine);

  useEffect(() => {
    const handleOnline = () => setIsOnline(true);
    const handleOffline = () => setIsOnline(false);

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return isOnline;
}
```

这样，多个组件都可以直接使用 useOnlineStatus()，避免重复逻辑。

## 自定义 Hook：命名规范

你必须遵循以下这些命名公约：

1. **组件** 名称必须以 **大写字母** 开头，例如 StatusBar 和 SaveButton，并且返回 JSX 作为 UI 内容。
2. **Hook** 名称必须以 **use** 开头，如 useState 或 useOnlineStatus，并可以返回任意值。

遵循这些规范，可以让代码更易读，快速区分组件和 Hook，避免混淆。

## 在 Hook 之间传递响应值 

在 React Hook 中，**响应值**（如异步请求结果、事件状态等）通常通过 **useState + useEffect** 或 **自定义 Hook** 传递给组件。

**常见方式：**

1️⃣ **useState + useEffect** 直接管理响应值：

```tsx
function Example() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('/api/data')
      .then(res => res.json())
      .then(setData);
  }, []);

  return <div>{data ? data.title : 'Loading...'}</div>;
}
```

2️⃣ **使用自定义 Hook 复用逻辑**：

```tsx
function useFetchData(url: string) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url)
      .then(res => res.json())
      .then(setData);
  }, [url]);

  return data;
}

function Example() {
  const data = useFetchData('/api/data');
  return <div>{data ? data.title : 'Loading...'}</div>;
}
```

✅ **结论：用 useState 存，useEffect 更新，自定义 Hook 复用！**

## 什么时候使用自定义 Hook

当多个组件需要 **复用相同的逻辑**（如数据获取、订阅事件、管理状态）时，就应该提取成 **自定义 Hook**，避免重复代码，提高可维护性。

✅ 适用场景：

1. 监听网络状态（useOnlineStatus）
2. 获取数据（useFetchData）
3. 处理定时器（useTimer）
4. 监听键盘/鼠标事件（useKeyPress）

**原则：逻辑复用，用 Hook！**





























